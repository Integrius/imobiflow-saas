<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fase 3: Automa√ß√µes Avan√ßadas | Guia BI + IA</title>
    <link rel="stylesheet" href="guia-styles.css">
</head>
<body>
    <div class="container">
        <header class="phase-header phase3">
            <div class="breadcrumb">
                <a href="guia-index.html">üè† √çndice</a> ‚Üí
                <a href="guia-fase2.html">üß† Fase 2</a> ‚Üí
                <span>Fase 3</span>
            </div>
            <h1>‚ö° Fase 3: Automa√ß√µes Avan√ßadas</h1>
            <p>Follow-ups, Recupera√ß√£o e Agendamento Inteligente</p>
            <div class="phase-meta">
                <span class="badge">‚è±Ô∏è 6 semanas</span>
                <span class="badge">üìä Avan√ßado</span>
                <span class="badge">ü§ñ 100% Automatizado</span>
            </div>
        </header>

        <nav class="nav-sticky">
            <a href="#visao">Vis√£o Geral</a>
            <a href="#followup">Follow-ups</a>
            <a href="#recuperacao">Recupera√ß√£o</a>
            <a href="#agendamento">Agendamento</a>
            <a href="#lembretes">Lembretes</a>
            <a href="#feedback">Feedback</a>
        </nav>

        <div class="content">
            <section id="visao">
                <h2>üìã Vis√£o Geral da Fase 3</h2>
                <div class="card card-info">
                    <h3>üéØ Objetivo</h3>
                    <p>Ao final desta fase, voc√™ ter√°:</p>
                    <ul>
                        <li>‚úÖ Follow-ups autom√°ticos inteligentes</li>
                        <li>‚úÖ Sistema de recupera√ß√£o de leads frios</li>
                        <li>‚úÖ Agendamento autom√°tico de visitas</li>
                        <li>‚úÖ Integra√ß√£o com Google Calendar</li>
                        <li>‚úÖ Lembretes autom√°ticos via WhatsApp e Telegram</li>
                        <li>‚úÖ Coleta autom√°tica de feedback</li>
                    </ul>
                </div>

                <div class="timeline-overview">
                    <div class="timeline-item">
                        <strong>Semanas 1-2: Follow-ups Autom√°ticos</strong>
                        <p>Sistema inteligente de retomada de contato</p>
                    </div>
                    <div class="timeline-item">
                        <strong>Semanas 3-4: Recupera√ß√£o de Leads</strong>
                        <p>Reativar leads inativos com estrat√©gias personalizadas</p>
                    </div>
                    <div class="timeline-item">
                        <strong>Semanas 5-6: Agendamento e Lembretes</strong>
                        <p>Gest√£o completa de visitas e compromissos</p>
                    </div>
                </div>
            </section>

            <section id="followup">
                <h2>üì¨ Follow-ups Autom√°ticos Inteligentes</h2>

                <div class="card card-warning">
                    <h3>üí° Conceito</h3>
                    <p>O sistema detecta quando um lead n√£o responde e automaticamente envia mensagens de follow-up personalizadas nos momentos ideais.</p>
                </div>

                <h3>Tarefa 3.1: Follow-up Automation Service</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>üìÅ apps/api/src/automation/followup.service.ts</span>
                        <button onclick="copyCode(this)">üìã Copiar</button>
                    </div>
                    <pre><code>import { PrismaClient } from '@prisma/client';
import { WhatsAppService } from '../messaging/services/whatsapp.service';
import { ClaudeService } from '../ai/services/claude.service';

const prisma = new PrismaClient();

interface FollowUpStrategy {
  name: string;
  delay: number; // horas
  condition: (lead: any) => boolean;
  messageTemplate: (lead: any) => Promise<string>;
}

export class FollowUpService {
  private whatsapp: WhatsAppService;
  private claude: ClaudeService;
  private strategies: FollowUpStrategy[];

  constructor() {
    this.whatsapp = new WhatsAppService();
    this.claude = new ClaudeService();
    this.strategies = this.defineStrategies();
  }

  private defineStrategies(): FollowUpStrategy[] {
    return [
      {
        name: 'no_response_24h',
        delay: 24,
        condition: (lead) => {
          const lastMessage = lead.messages[0];
          if (!lastMessage) return false;

          const hoursSince = (Date.now() - lastMessage.createdAt.getTime()) / (1000 * 60 * 60);
          return lastMessage.direction === 'outbound' && hoursSince >= 24;
        },
        messageTemplate: async (lead) => {
          return await this.generateFollowUpMessage(lead, '24h_no_response');
        }
      },
      {
        name: 'high_score_no_schedule',
        delay: 12,
        condition: (lead) => {
          return lead.score >= 70 && lead.status === 'active' && !lead.scheduledVisitAt;
        },
        messageTemplate: async (lead) => {
          return await this.generateFollowUpMessage(lead, 'high_score_schedule');
        }
      },
      {
        name: 'post_property_view',
        delay: 4,
        condition: (lead) => {
          if (!lead.propertyViews || lead.propertyViews.length === 0) return false;

          const lastView = lead.propertyViews[0];
          const hoursSince = (Date.now() - lastView.viewedAt.getTime()) / (1000 * 60 * 60);

          // Visualizou im√≥vel mas n√£o respondeu em 4h
          return hoursSince >= 4 && hoursSince < 24;
        },
        messageTemplate: async (lead) => {
          const lastView = lead.propertyViews[0];
          return await this.generatePropertyFollowUp(lead, lastView.property);
        }
      },
      {
        name: 'engagement_drop',
        delay: 48,
        condition: (lead) => {
          // Lead que estava muito ativo mas parou de responder
          if (lead.messages.length < 10) return false;

          const recentMessages = lead.messages.slice(0, 5);
          const olderMessages = lead.messages.slice(5, 15);

          const recentDays = this.getDaysSinceLastMessage(recentMessages);
          const wasPreviouslyActive = olderMessages.some(m =>
            m.direction === 'inbound'
          );

          return recentDays >= 2 && wasPreviouslyActive;
        },
        messageTemplate: async (lead) => {
          return await this.generateFollowUpMessage(lead, 'engagement_drop');
        }
      }
    ];
  }

  async processFollowUps(tenantId: string): Promise<void> {
    console.log('üîÑ Processando follow-ups autom√°ticos...\n');

    const leads = await prisma.lead.findMany({
      where: {
        tenantId,
        status: { in: ['active', 'contacted'] },
        optedOutFromAutomation: false
      },
      include: {
        messages: {
          orderBy: { createdAt: 'desc' },
          take: 20
        },
        propertyViews: {
          orderBy: { viewedAt: 'desc' },
          take: 5,
          include: { property: true }
        }
      }
    });

    let sentCount = 0;

    for (const lead of leads) {
      for (const strategy of this.strategies) {
        if (strategy.condition(lead)) {
          // Verificar se j√° enviou follow-up desta estrat√©gia recentemente
          const alreadySent = await this.wasFollowUpRecentlySent(
            lead.id,
            strategy.name,
            strategy.delay
          );

          if (!alreadySent) {
            await this.sendFollowUp(lead, strategy);
            sentCount++;
            break; // Apenas uma estrat√©gia por lead por execu√ß√£o
          }
        }
      }
    }

    console.log(`‚úÖ Follow-ups enviados: ${sentCount}\n`);
  }

  private async sendFollowUp(lead: any, strategy: FollowUpStrategy): Promise<void> {
    try {
      const message = await strategy.messageTemplate(lead);

      // Enviar via WhatsApp
      await this.whatsapp.sendMessageWithTyping(lead.phone, message);

      // Registrar follow-up
      await prisma.followUp.create({
        data: {
          leadId: lead.id,
          strategy: strategy.name,
          message,
          sentAt: new Date()
        }
      });

      console.log(`üì¨ Follow-up enviado para ${lead.name || lead.phone}: ${strategy.name}`);
    } catch (error) {
      console.error(`‚ùå Erro ao enviar follow-up para ${lead.id}:`, error);
    }
  }

  private async generateFollowUpMessage(
    lead: any,
    context: string
  ): Promise<string> {
    const conversationSummary = lead.messages
      .slice(0, 5)
      .map((m: any) => `${m.direction === 'inbound' ? 'Lead' : 'Sofia'}: ${m.content}`)
      .join('\n');

    const prompt = `
Voc√™ √© Sofia, assistente da Vivoly Imobili√°ria.

CONTEXTO: ${context}

INFORMA√á√ïES DO LEAD:
- Nome: ${lead.name || 'N√£o informado'}
- Score: ${lead.score}/100
- √öltima intera√ß√£o: ${this.getDaysSinceLastMessage(lead.messages)} dias atr√°s

√öLTIMAS MENSAGENS:
${conversationSummary}

Gere uma mensagem de follow-up:
- Casual e amig√°vel
- N√£o insistente
- Agregue valor (nova informa√ß√£o, dica, im√≥vel)
- M√°ximo 2-3 frases
- Inclua uma pergunta ou call-to-action

Sua mensagem:
    `;

    return await this.claude.generateResponse(prompt, undefined, {
      maxTokens: 300,
      temperature: 0.8
    });
  }

  private async generatePropertyFollowUp(
    lead: any,
    property: any
  ): Promise<string> {
    const prompt = `
Gere uma mensagem de follow-up para um lead que visualizou este im√≥vel:

IM√ìVEL: ${property.title}
TIPO: ${property.type}
PRE√áO: R$ ${property.price?.toLocaleString('pt-BR')}
QUARTOS: ${property.bedrooms}

O lead visualizou mas n√£o comentou nada. Seja sutil e √∫til.

Sua mensagem (2-3 frases):
    `;

    return await this.claude.generateResponse(prompt, undefined, {
      maxTokens: 250,
      temperature: 0.8
    });
  }

  private async wasFollowUpRecentlySent(
    leadId: string,
    strategyName: string,
    delayHours: number
  ): Promise<boolean> {
    const cutoff = new Date();
    cutoff.setHours(cutoff.getHours() - delayHours);

    const recent = await prisma.followUp.findFirst({
      where: {
        leadId,
        strategy: strategyName,
        sentAt: { gte: cutoff }
      }
    });

    return recent !== null;
  }

  private getDaysSinceLastMessage(messages: any[]): number {
    if (messages.length === 0) return 999;

    const lastMessage = messages[0];
    return Math.floor(
      (Date.now() - lastMessage.createdAt.getTime()) / (1000 * 60 * 60 * 24)
    );
  }
}</code></pre>
                </div>
            </section>

            <section id="recuperacao">
                <h2>üîÑ Recupera√ß√£o de Leads Frios</h2>

                <h3>Tarefa 3.2: Lead Recovery Service</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>üìÅ apps/api/src/automation/lead-recovery.service.ts</span>
                        <button onclick="copyCode(this)">üìã Copiar</button>
                    </div>
                    <pre><code>import { PrismaClient } from '@prisma/client';
import { WhatsAppService } from '../messaging/services/whatsapp.service';
import { ClaudeService } from '../ai/services/claude.service';

const prisma = new PrismaClient();

export class LeadRecoveryService {
  private whatsapp: WhatsAppService;
  private claude: ClaudeService;

  constructor() {
    this.whatsapp = new WhatsAppService();
    this.claude = new ClaudeService();
  }

  async identifyColdLeads(tenantId: string): Promise<any[]> {
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

    // Leads que:
    // 1. Foram ativos (tiveram conversa)
    // 2. N√£o respondem h√° mais de 7 dias
    // 3. N√£o foram fechados/perdidos
    // 4. T√™m score razo√°vel (mostraram interesse)
    const coldLeads = await prisma.lead.findMany({
      where: {
        tenantId,
        status: { in: ['active', 'contacted'] },
        score: { gte: 40 }, // Pelo menos interesse moderado
        messages: {
          some: {
            createdAt: { lt: sevenDaysAgo }
          }
        }
      },
      include: {
        messages: {
          orderBy: { createdAt: 'desc' },
          take: 20
        },
        propertyViews: {
          include: { property: true }
        }
      }
    });

    // Filtrar apenas os que realmente est√£o frios (√∫ltima mensagem h√° mais de 7 dias)
    return coldLeads.filter(lead => {
      const lastMessage = lead.messages[0];
      if (!lastMessage) return false;

      const daysSince = (Date.now() - lastMessage.createdAt.getTime()) / (1000 * 60 * 60 * 24);
      return daysSince >= 7;
    });
  }

  async attemptRecovery(tenantId: string): Promise<{
    attempted: number;
    sent: number;
  }> {
    console.log('üîÑ Iniciando recupera√ß√£o de leads frios...\n');

    const coldLeads = await this.identifyColdLeads(tenantId);
    console.log(`‚ùÑÔ∏è Leads frios identificados: ${coldLeads.length}\n`);

    let sentCount = 0;

    for (const lead of coldLeads) {
      // Verificar se j√° tentou recuperar recentemente
      const recentRecoveryAttempt = await prisma.recoveryAttempt.findFirst({
        where: {
          leadId: lead.id,
          attemptedAt: {
            gte: new Date(Date.now() - 14 * 24 * 60 * 60 * 1000) // 14 dias
          }
        }
      });

      if (recentRecoveryAttempt) {
        console.log(`‚è≠Ô∏è Lead ${lead.id} j√° teve tentativa recente`);
        continue;
      }

      // Gerar mensagem personalizada de recupera√ß√£o
      const message = await this.generateRecoveryMessage(lead);

      try {
        // Enviar mensagem
        await this.whatsapp.sendMessageWithTyping(lead.phone, message);

        // Registrar tentativa
        await prisma.recoveryAttempt.create({
          data: {
            leadId: lead.id,
            strategy: this.determineRecoveryStrategy(lead),
            message,
            attemptedAt: new Date()
          }
        });

        sentCount++;
        console.log(`‚úÖ Mensagem de recupera√ß√£o enviada: ${lead.name || lead.phone}`);

        // Delay entre mensagens (mais humano)
        await this.delay(5000);
      } catch (error) {
        console.error(`‚ùå Erro ao tentar recuperar lead ${lead.id}:`, error);
      }
    }

    console.log(`\nüéâ Recupera√ß√£o conclu√≠da: ${sentCount}/${coldLeads.length} mensagens enviadas\n`);

    return {
      attempted: coldLeads.length,
      sent: sentCount
    };
  }

  private determineRecoveryStrategy(lead: any): string {
    const daysSince = this.getDaysSinceLastMessage(lead.messages);

    if (daysSince >= 30) return 'long_term_inactive';
    if (daysSince >= 14) return 'medium_term_inactive';
    if (lead.propertyViews?.length > 0) return 'viewed_but_not_engaged';
    if (lead.score >= 60) return 'high_score_dropped';
    return 'general_reactivation';
  }

  private async generateRecoveryMessage(lead: any): Promise<string> {
    const strategy = this.determineRecoveryStrategy(lead);
    const daysSince = this.getDaysSinceLastMessage(lead.messages);

    let context = '';

    switch (strategy) {
      case 'long_term_inactive':
        context = 'Lead inativo h√° mais de 30 dias. Ofere√ßa algo novo e valioso.';
        break;
      case 'medium_term_inactive':
        context = 'Lead parou de responder h√° 2-4 semanas. Retome gentilmente.';
        break;
      case 'viewed_but_not_engaged':
        context = `Lead visualizou ${lead.propertyViews.length} im√≥veis mas n√£o agendou visita.`;
        break;
      case 'high_score_dropped':
        context = 'Lead tinha alto interesse (score ${lead.score}) mas sumiu.';
        break;
      default:
        context = 'Reativa√ß√£o geral de lead inativo.';
    }

    const lastMessages = lead.messages
      .slice(0, 3)
      .map((m: any) => `${m.direction === 'inbound' ? 'Lead' : 'IA'}: ${m.content}`)
      .join('\n');

    const prompt = `
Voc√™ √© Sofia da Vivoly Imobili√°ria.

SITUA√á√ÉO: ${context}
√öLTIMA INTERA√á√ÉO: H√° ${daysSince} dias

√öLTIMAS MENSAGENS:
${lastMessages}

PREFER√äNCIAS CONHECIDAS:
${lead.propertyType ? `- Tipo: ${lead.propertyType}` : ''}
${lead.bedrooms ? `- Quartos: ${lead.bedrooms}` : ''}
${lead.budgetMax ? `- Or√ßamento: at√© R$ ${lead.budgetMax.toLocaleString('pt-BR')}` : ''}

Gere uma mensagem de recupera√ß√£o que:
1. Seja amig√°vel e n√£o invasiva
2. Ofere√ßa valor real (novidades, dicas, oportunidade)
3. Seja espec√≠fica para o perfil do lead
4. M√°ximo 3 frases
5. Tenha um call-to-action suave

ESTRAT√âGIAS EFETIVAS:
- "Temos novos im√≥veis que combinam com voc√™"
- "O mercado mudou, quer saber como isso te beneficia?"
- "Lembrei de voc√™ ao ver este lan√ßamento"
- Evite: "Voc√™ ainda est√° interessado?"

Sua mensagem:
    `;

    return await this.claude.generateResponse(prompt, undefined, {
      maxTokens: 300,
      temperature: 0.9 // Mais criativo
    });
  }

  private getDaysSinceLastMessage(messages: any[]): number {
    if (messages.length === 0) return 999;
    const lastMessage = messages[0];
    return Math.floor((Date.now() - lastMessage.createdAt.getTime()) / (1000 * 60 * 60 * 24));
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}</code></pre>
                </div>
            </section>

            <section id="agendamento">
                <h2>üìÖ Agendamento Inteligente de Visitas</h2>

                <h3>Tarefa 3.3: Smart Scheduling Service</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>üìÅ apps/api/src/automation/smart-scheduling.service.ts</span>
                        <button onclick="copyCode(this)">üìã Copiar</button>
                    </div>
                    <pre><code>import { PrismaClient } from '@prisma/client';
import { ClaudeService } from '../ai/services/claude.service';
import { google } from 'googleapis';

const prisma = new PrismaClient();

export class SmartSchedulingService {
  private claude: ClaudeService;
  private calendar: any;

  constructor() {
    this.claude = new ClaudeService();
    this.initializeGoogleCalendar();
  }

  private initializeGoogleCalendar() {
    // Configurar OAuth2 do Google Calendar
    const auth = new google.auth.OAuth2(
      process.env.GOOGLE_CLIENT_ID,
      process.env.GOOGLE_CLIENT_SECRET,
      process.env.GOOGLE_REDIRECT_URI
    );

    auth.setCredentials({
      refresh_token: process.env.GOOGLE_REFRESH_TOKEN
    });

    this.calendar = google.calendar({ version: 'v3', auth });
  }

  async detectSchedulingIntent(message: string): Promise<{
    isSchedulingRequest: boolean;
    preferredDate?: Date;
    preferredTime?: string;
    flexibility: 'flexible' | 'specific' | 'urgent';
  }> {
    const prompt = `
Analise esta mensagem e detecte se √© uma solicita√ß√£o de agendamento de visita:

MENSAGEM: "${message}"

Retorne JSON:
{
  "isSchedulingRequest": boolean,
  "preferredDate": "YYYY-MM-DD" | null,
  "preferredTime": "HH:MM" | "manh√£" | "tarde" | "noite" | null,
  "flexibility": "flexible" | "specific" | "urgent"
}

EXEMPLOS:
"Quero agendar uma visita" -> isSchedulingRequest: true, flexibility: flexible
"Pode ser amanh√£ √†s 14h?" -> isSchedulingRequest: true, preferredDate: tomorrow, preferredTime: "14:00", flexibility: specific
"Preciso ver hoje!" -> isSchedulingRequest: true, flexibility: urgent
"Quanto custa?" -> isSchedulingRequest: false
    `;

    try {
      const result = await this.claude.analyze(prompt);
      return {
        isSchedulingRequest: result.isSchedulingRequest || false,
        preferredDate: result.preferredDate ? new Date(result.preferredDate) : undefined,
        preferredTime: result.preferredTime,
        flexibility: result.flexibility || 'flexible'
      };
    } catch (error) {
      console.error('Erro ao detectar inten√ß√£o de agendamento:', error);
      return { isSchedulingRequest: false, flexibility: 'flexible' };
    }
  }

  async findAvailableSlots(
    brokerId: string,
    startDate: Date,
    endDate: Date
  ): Promise<Array<{ start: Date; end: Date }>> {
    try {
      const response = await this.calendar.freebusy.query({
        requestBody: {
          timeMin: startDate.toISOString(),
          timeMax: endDate.toISOString(),
          items: [{ id: `${brokerId}@vivoly.com` }]
        }
      });

      const busy = response.data.calendars[`${brokerId}@vivoly.com`]?.busy || [];

      // Gerar slots de 1 hora das 9h √†s 18h
      const slots: Array<{ start: Date; end: Date }> = [];
      let current = new Date(startDate);

      while (current < endDate) {
        const hour = current.getHours();

        // Hor√°rio comercial: 9h-18h
        if (hour >= 9 && hour < 18) {
          const slotStart = new Date(current);
          const slotEnd = new Date(current);
          slotEnd.setHours(slotEnd.getHours() + 1);

          // Verificar se slot est√° livre
          const isBusy = busy.some((b: any) => {
            const busyStart = new Date(b.start);
            const busyEnd = new Date(b.end);
            return slotStart < busyEnd && slotEnd > busyStart;
          });

          if (!isBusy) {
            slots.push({ start: slotStart, end: slotEnd });
          }
        }

        current.setHours(current.getHours() + 1);
      }

      return slots;
    } catch (error) {
      console.error('Erro ao buscar hor√°rios dispon√≠veis:', error);
      return [];
    }
  }

  async suggestSlots(
    brokerId: string,
    preferredDate?: Date,
    preferredTime?: string,
    flexibility: string = 'flexible'
  ): Promise<string> {
    const startDate = preferredDate || new Date();
    const endDate = new Date(startDate);
    endDate.setDate(endDate.getDate() + 7); // Pr√≥ximos 7 dias

    const availableSlots = await this.findAvailableSlots(brokerId, startDate, endDate);

    if (availableSlots.length === 0) {
      return 'No momento n√£o temos hor√°rios dispon√≠veis esta semana. Que tal semana que vem?';
    }

    // Filtrar por prefer√™ncia de hor√°rio
    let filteredSlots = availableSlots;

    if (preferredTime) {
      filteredSlots = this.filterByTimePreference(availableSlots, preferredTime);
    }

    // Formatar sugest√µes
    const suggestions = filteredSlots.slice(0, 3).map(slot =>
      this.formatSlot(slot.start)
    );

    if (flexibility === 'urgent') {
      const today = suggestions.filter(s => s.includes('Hoje'));
      if (today.length > 0) {
        return `Temos dispon√≠vel hoje: ${today.join(', ')}. Qual prefere?`;
      }
    }

    return `Tenho estes hor√°rios dispon√≠veis: ${suggestions.join(', ')}. Qual funciona melhor pra voc√™?`;
  }

  async createVisit(
    leadId: string,
    brokerId: string,
    propertyId: string,
    scheduledAt: Date,
    duration: number = 60 // minutos
  ): Promise<any> {
    // 1. Criar no banco de dados
    const visit = await prisma.visit.create({
      data: {
        leadId,
        brokerId,
        propertyId,
        scheduledAt,
        duration,
        status: 'scheduled'
      },
      include: {
        lead: true,
        broker: true,
        property: true
      }
    });

    // 2. Criar evento no Google Calendar
    const endTime = new Date(scheduledAt);
    endTime.setMinutes(endTime.getMinutes() + duration);

    try {
      await this.calendar.events.insert({
        calendarId: `${brokerId}@vivoly.com`,
        requestBody: {
          summary: `Visita: ${visit.property.title}`,
          description: `Cliente: ${visit.lead.name || visit.lead.phone}\nIm√≥vel: ${visit.property.title}`,
          start: { dateTime: scheduledAt.toISOString() },
          end: { dateTime: endTime.toISOString() },
          attendees: [
            { email: visit.broker.email },
            { email: visit.lead.email || undefined }
          ].filter(a => a.email),
          reminders: {
            useDefault: false,
            overrides: [
              { method: 'email', minutes: 60 },
              { method: 'popup', minutes: 30 }
            ]
          }
        }
      });

      console.log('‚úÖ Visita criada no Google Calendar');
    } catch (error) {
      console.error('‚ùå Erro ao criar evento no Calendar:', error);
    }

    return visit;
  }

  private filterByTimePreference(
    slots: Array<{ start: Date; end: Date }>,
    preference: string
  ): Array<{ start: Date; end: Date }> {
    return slots.filter(slot => {
      const hour = slot.start.getHours();

      switch (preference.toLowerCase()) {
        case 'manh√£':
        case 'morning':
          return hour >= 9 && hour < 12;
        case 'tarde':
        case 'afternoon':
          return hour >= 12 && hour < 17;
        case 'noite':
        case 'evening':
          return hour >= 17 && hour < 20;
        default:
          // Tentar extrair hora espec√≠fica
          const timeMatch = preference.match(/(\d{1,2}):?(\d{2})?/);
          if (timeMatch) {
            const preferredHour = parseInt(timeMatch[1]);
            return hour === preferredHour;
          }
          return true;
      }
    });
  }

  private formatSlot(date: Date): string {
    const today = new Date();
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    const isToday = date.toDateString() === today.toDateString();
    const isTomorrow = date.toDateString() === tomorrow.toDateString();

    const time = date.toLocaleTimeString('pt-BR', {
      hour: '2-digit',
      minute: '2-digit'
    });

    if (isToday) return `Hoje √†s ${time}`;
    if (isTomorrow) return `Amanh√£ √†s ${time}`;

    const weekday = date.toLocaleDateString('pt-BR', { weekday: 'long' });
    return `${weekday} √†s ${time}`;
  }
}</code></pre>
                </div>
            </section>

            <section id="lembretes">
                <h2>‚è∞ Sistema de Lembretes Autom√°ticos</h2>

                <h3>Tarefa 3.4: Reminder Service</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>üìÅ apps/api/src/automation/reminder.service.ts</span>
                        <button onclick="copyCode(this)">üìã Copiar</button>
                    </div>
                    <pre><code>import { PrismaClient } from '@prisma/client';
import { WhatsAppService } from '../messaging/services/whatsapp.service';
import { TelegramService } from '../messaging/services/telegram.service';

const prisma = new PrismaClient();

export class ReminderService {
  private whatsapp: WhatsAppService;
  private telegram: TelegramService;

  constructor() {
    this.whatsapp = new WhatsAppService();
    this.telegram = new TelegramService();
  }

  async processReminders(): Promise<void> {
    console.log('‚è∞ Processando lembretes...\n');

    await Promise.all([
      this.sendVisitReminders(),
      this.sendPaymentReminders(),
      this.sendDocumentReminders()
    ]);

    console.log('‚úÖ Lembretes processados\n');
  }

  private async sendVisitReminders(): Promise<void> {
    // Buscar visitas agendadas para as pr√≥ximas 24 horas
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);

    const upcomingVisits = await prisma.visit.findMany({
      where: {
        scheduledAt: {
          gte: new Date(),
          lte: tomorrow
        },
        status: 'scheduled',
        reminderSent: false
      },
      include: {
        lead: true,
        broker: true,
        property: true
      }
    });

    for (const visit of upcomingVisits) {
      const timeUntil = this.getTimeUntilVisit(visit.scheduledAt);

      // Lembrete para o lead
      const leadMessage =
        `‚è∞ *Lembrete de Visita*\n\n` +
        `Ol√° ${visit.lead.name}! Lembre-se da sua visita ao im√≥vel:\n\n` +
        `üè† *${visit.property.title}*\n` +
        `üìç ${visit.property.address}\n` +
        `üïê ${this.formatDateTime(visit.scheduledAt)}\n` +
        `üë§ Corretor: ${visit.broker.name}\n\n` +
        `${timeUntil}\n\n` +
        `Alguma d√∫vida ou precisa reagendar? √â s√≥ responder!`;

      await this.whatsapp.sendMessage(visit.lead.phone, leadMessage);

      // Lembrete para o corretor via Telegram
      if (visit.broker.telegramUserId) {
        const brokerMessage =
          `‚è∞ *Lembrete de Visita*\n\n` +
          `üìÖ ${this.formatDateTime(visit.scheduledAt)}\n` +
          `üë§ Cliente: ${visit.lead.name || visit.lead.phone}\n` +
          `üè† ${visit.property.title}\n` +
          `üìç ${visit.property.address}\n\n` +
          `${timeUntil}`;

        await this.telegram.sendMessage(
          visit.broker.telegramUserId,
          brokerMessage
        );
      }

      // Marcar como enviado
      await prisma.visit.update({
        where: { id: visit.id },
        data: { reminderSent: true }
      });

      console.log(`‚úÖ Lembrete de visita enviado: ${visit.id}`);
    }
  }

  private async sendPaymentReminders(): Promise<void> {
    // Buscar negocia√ß√µes com pagamentos pendentes
    const pendingPayments = await prisma.payment.findMany({
      where: {
        status: 'pending',
        dueDate: {
          lte: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000) // 3 dias
        },
        reminderSent: false
      },
      include: {
        deal: {
          include: {
            lead: true,
            property: true
          }
        }
      }
    });

    for (const payment of pendingPayments) {
      const daysUntilDue = Math.ceil(
        (payment.dueDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)
      );

      let urgency = '';
      if (daysUntilDue === 0) urgency = 'üö® VENCE HOJE';
      else if (daysUntilDue === 1) urgency = '‚ö†Ô∏è Vence amanh√£';
      else urgency = `Vence em ${daysUntilDue} dias`;

      const message =
        `üí∞ *Lembrete de Pagamento*\n\n` +
        `${urgency}\n\n` +
        `Referente a: ${payment.deal.property.title}\n` +
        `Valor: R$ ${payment.amount.toLocaleString('pt-BR')}\n` +
        `Vencimento: ${this.formatDate(payment.dueDate)}\n\n` +
        `Precisa de ajuda com o pagamento? Estamos √† disposi√ß√£o!`;

      await this.whatsapp.sendMessage(payment.deal.lead.phone, message);

      await prisma.payment.update({
        where: { id: payment.id },
        data: { reminderSent: true }
      });

      console.log(`‚úÖ Lembrete de pagamento enviado: ${payment.id}`);
    }
  }

  private async sendDocumentReminders(): Promise<void> {
    // Buscar deals com documentos pendentes
    const pendingDocs = await prisma.deal.findMany({
      where: {
        status: { in: ['documentation', 'contract_review'] },
        documentsPending: { not: null }
      },
      include: {
        lead: true,
        property: true
      }
    });

    for (const deal of pendingDocs) {
      if (!deal.documentsPending || deal.documentsPending.length === 0) continue;

      const message =
        `üìÑ *Documentos Pendentes*\n\n` +
        `Ol√°! Para darmos continuidade √† negocia√ß√£o do im√≥vel ${deal.property.title}, ` +
        `ainda precisamos dos seguintes documentos:\n\n` +
        `${(deal.documentsPending as string[]).map(doc => `üìé ${doc}`).join('\n')}\n\n` +
        `Pode enviar aqui mesmo pelo WhatsApp ou trazer na pr√≥xima reuni√£o!`;

      await this.whatsapp.sendMessage(deal.lead.phone, message);

      console.log(`‚úÖ Lembrete de documentos enviado: ${deal.id}`);
    }
  }

  private getTimeUntilVisit(scheduledAt: Date): string {
    const hours = Math.floor((scheduledAt.getTime() - Date.now()) / (1000 * 60 * 60));

    if (hours < 1) return 'A visita √© daqui a pouco!';
    if (hours < 3) return `Faltam ${hours} horas`;
    if (hours < 24) return `Faltam ${hours} horas`;

    const days = Math.floor(hours / 24);
    return `Faltam ${days} dia${days > 1 ? 's' : ''}`;
  }

  private formatDateTime(date: Date): string {
    return date.toLocaleString('pt-BR', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  }

  private formatDate(date: Date): string {
    return date.toLocaleDateString('pt-BR', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  }
}</code></pre>
                </div>
            </section>

            <section id="feedback">
                <h2>üí¨ Sistema de Feedback Autom√°tico</h2>

                <h3>Tarefa 3.5: Feedback Collection Service</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>üìÅ apps/api/src/automation/feedback.service.ts</span>
                        <button onclick="copyCode(this)">üìã Copiar</button>
                    </div>
                    <pre><code>import { PrismaClient } from '@prisma/client';
import { WhatsAppService } from '../messaging/services/whatsapp.service';
import { ClaudeService } from '../ai/services/claude.service';

const prisma = new PrismaClient();

export class FeedbackService {
  private whatsapp: WhatsAppService;
  private claude: ClaudeService;

  constructor() {
    this.whatsapp = new WhatsAppService();
    this.claude = new ClaudeService();
  }

  async collectPostVisitFeedback(): Promise<void> {
    // Buscar visitas realizadas nas √∫ltimas 24h sem feedback
    const oneDayAgo = new Date();
    oneDayAgo.setDate(oneDayAgo.getDate() - 1);

    const visits = await prisma.visit.findMany({
      where: {
        status: 'completed',
        scheduledAt: { gte: oneDayAgo },
        feedbackCollected: false
      },
      include: {
        lead: true,
        property: true
      }
    });

    for (const visit of visits) {
      const message =
        `Oi ${visit.lead.name}! üòä\n\n` +
        `Como foi a visita ao ${visit.property.title}? ` +
        `Sua opini√£o √© muito importante pra gente!\n\n` +
        `Pode responder em poucas palavras:\n` +
        `- O que achou do im√≥vel?\n` +
        `- Atendeu suas expectativas?\n` +
        `- Tem interesse em avan√ßar?`;

      await this.whatsapp.sendMessage(visit.lead.phone, message);

      await prisma.visit.update({
        where: { id: visit.id },
        data: { feedbackRequested: true }
      });

      console.log(`‚úÖ Feedback solicitado: Visita ${visit.id}`);
    }
  }

  async analyzeFeedback(visitId: string, feedbackText: string): Promise<void> {
    const prompt = `
Analise este feedback de uma visita a im√≥vel e retorne JSON:

FEEDBACK: "${feedbackText}"

Retorne:
{
  "sentiment": "positive" | "neutral" | "negative",
  "interest_level": 1-10,
  "concerns": ["preocupa√ß√£o 1", ...],
  "positive_points": ["ponto positivo 1", ...],
  "next_action": "schedule_second_visit" | "send_proposal" | "address_concerns" | "follow_up" | "close_lost"
}
    `;

    const analysis = await this.claude.analyze(prompt);

    await prisma.visit.update({
      where: { id: visitId },
      data: {
        feedback: feedbackText,
        feedbackAnalysis: analysis,
        feedbackCollected: true
      }
    });

    // Atualizar score do lead baseado no feedback
    const visit = await prisma.visit.findUnique({
      where: { id: visitId },
      include: { lead: true }
    });

    if (visit) {
      const scoreAdjustment = this.calculateScoreAdjustment(analysis);

      await prisma.lead.update({
        where: { id: visit.leadId },
        data: {
          score: {
            increment: scoreAdjustment
          }
        }
      });
    }
  }

  async collectPostDealFeedback(): Promise<void> {
    // Buscar negocia√ß√µes fechadas recentemente
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

    const closedDeals = await prisma.deal.findMany({
      where: {
        status: 'closed_won',
        closedAt: { gte: sevenDaysAgo },
        feedbackCollected: false
      },
      include: {
        lead: true,
        property: true,
        broker: true
      }
    });

    for (const deal of closedDeals) {
      const message =
        `Ol√° ${deal.lead.name}! üéâ\n\n` +
        `Parab√©ns pela aquisi√ß√£o do seu novo im√≥vel! ` +
        `Gostar√≠amos muito de saber como foi sua experi√™ncia conosco.\n\n` +
        `De 0 a 10, como voc√™ avalia:\n\n` +
        `1Ô∏è‚É£ Atendimento geral\n` +
        `2Ô∏è‚É£ Agilidade no processo\n` +
        `3Ô∏è‚É£ Atendimento do corretor ${deal.broker.name}\n` +
        `4Ô∏è‚É£ Recomendaria a Vivoly para amigos?\n\n` +
        `Sua opini√£o nos ajuda a melhorar sempre! üôè`;

      await this.whatsapp.sendMessage(deal.lead.phone, message);

      await prisma.deal.update({
        where: { id: deal.id },
        data: { feedbackRequested: true }
      });

      console.log(`‚úÖ Feedback p√≥s-venda solicitado: Deal ${deal.id}`);
    }
  }

  private calculateScoreAdjustment(analysis: any): number {
    let adjustment = 0;

    // Sentimento
    if (analysis.sentiment === 'positive') adjustment += 10;
    else if (analysis.sentiment === 'negative') adjustment -= 10;

    // N√≠vel de interesse
    if (analysis.interest_level >= 8) adjustment += 15;
    else if (analysis.interest_level >= 6) adjustment += 5;
    else if (analysis.interest_level <= 3) adjustment -= 10;

    // A√ß√£o recomendada
    switch (analysis.next_action) {
      case 'schedule_second_visit':
      case 'send_proposal':
        adjustment += 10;
        break;
      case 'close_lost':
        adjustment -= 20;
        break;
    }

    return adjustment;
  }
}</code></pre>
                </div>
            </section>

            <section id="cron">
                <h2>‚öôÔ∏è Configura√ß√£o de Jobs Autom√°ticos (Cron)</h2>

                <div class="code-block">
                    <div class="code-header">
                        <span>üìÅ apps/api/src/automation/cron-jobs.ts</span>
                        <button onclick="copyCode(this)">üìã Copiar</button>
                    </div>
                    <pre><code>import cron from 'node-cron';
import { FollowUpService } from './followup.service';
import { LeadRecoveryService } from './lead-recovery.service';
import { ReminderService } from './reminder.service';
import { FeedbackService } from './feedback.service';
import { LeadScoringMLService } from '../ai/ml/lead-scoring.service';

export class AutomationScheduler {
  private followUpService: FollowUpService;
  private recoveryService: LeadRecoveryService;
  private reminderService: ReminderService;
  private feedbackService: FeedbackService;
  private scoringService: LeadScoringMLService;

  constructor() {
    this.followUpService = new FollowUpService();
    this.recoveryService = new LeadRecoveryService();
    this.reminderService = new ReminderService();
    this.feedbackService = new FeedbackService();
    this.scoringService = new LeadScoringMLService();
  }

  startAll() {
    console.log('‚öôÔ∏è Iniciando jobs autom√°ticos...\n');

    // Follow-ups: a cada 6 horas
    cron.schedule('0 */6 * * *', async () => {
      console.log('\nüîÑ [CRON] Executando follow-ups...');
      await this.followUpService.processFollowUps('default-tenant');
    });

    // Recupera√ß√£o de leads: diariamente √†s 10h
    cron.schedule('0 10 * * *', async () => {
      console.log('\nüîÑ [CRON] Executando recupera√ß√£o de leads...');
      await this.recoveryService.attemptRecovery('default-tenant');
    });

    // Lembretes: a cada 2 horas
    cron.schedule('0 */2 * * *', async () => {
      console.log('\n‚è∞ [CRON] Processando lembretes...');
      await this.reminderService.processReminders();
    });

    // Feedback p√≥s-visita: a cada 4 horas
    cron.schedule('0 */4 * * *', async () => {
      console.log('\nüí¨ [CRON] Coletando feedback de visitas...');
      await this.feedbackService.collectPostVisitFeedback();
    });

    // Feedback p√≥s-venda: diariamente √†s 15h
    cron.schedule('0 15 * * *', async () => {
      console.log('\nüí¨ [CRON] Coletando feedback p√≥s-venda...');
      await this.feedbackService.collectPostDealFeedback();
    });

    // Atualiza√ß√£o de scores: diariamente √†s 2h (madrugada)
    cron.schedule('0 2 * * *', async () => {
      console.log('\nüìä [CRON] Atualizando scores de leads...');
      await this.scoringService.batchUpdateScores('default-tenant');
    });

    console.log('‚úÖ Jobs agendados:');
    console.log('   - Follow-ups: a cada 6h');
    console.log('   - Recupera√ß√£o de leads: 10h diariamente');
    console.log('   - Lembretes: a cada 2h');
    console.log('   - Feedback visitas: a cada 4h');
    console.log('   - Feedback vendas: 15h diariamente');
    console.log('   - Score update: 2h diariamente\n');
  }
}

// Exportar para uso no main.ts
export function initializeAutomation() {
  const scheduler = new AutomationScheduler();
  scheduler.startAll();
}</code></pre>
                </div>

                <div class="card card-success">
                    <h3>üéâ Sistema 100% Automatizado!</h3>
                    <p>Com todos os jobs configurados, o sistema agora:</p>
                    <ul>
                        <li>‚úÖ Faz follow-up autom√°tico de leads</li>
                        <li>‚úÖ Recupera leads inativos</li>
                        <li>‚úÖ Envia lembretes de visitas e pagamentos</li>
                        <li>‚úÖ Coleta feedback automaticamente</li>
                        <li>‚úÖ Atualiza scores continuamente</li>
                        <li>‚úÖ Funciona 24/7 sem interven√ß√£o manual</li>
                    </ul>
                </div>
            </section>

            <div class="card card-info" style="margin-top: 50px;">
                <h3>üéä Parab√©ns! Fase 3 Conclu√≠da!</h3>
                <p>Voc√™ implementou um sistema completamente automatizado de gest√£o de leads!</p>
                <p><strong>Pr√≥ximos passos:</strong></p>
                <ul>
                    <li><a href="guia-testes.html">Testes Completos do Sistema</a></li>
                    <li><a href="guia-deploy.html">Deploy para Produ√ß√£o</a></li>
                </ul>
            </div>
        </div>

        <footer class="nav-footer">
            <a href="guia-fase2.html" class="btn-nav">‚Üê Fase 2</a>
            <a href="guia-index.html" class="btn-nav">üè† √çndice</a>
            <a href="guia-testes.html" class="btn-nav">Testes ‚Üí</a>
        </footer>
    </div>

    <script src="guia-scripts.js"></script>
</body>
</html>
