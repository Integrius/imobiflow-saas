<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fase 1: MVP - FundaÃ§Ã£o | Guia BI + IA</title>
    <link rel="stylesheet" href="guia-styles.css">
</head>
<body>
    <div class="container">
        <header class="phase-header phase1">
            <div class="breadcrumb">
                <a href="guia-index.html">ğŸ  Ãndice</a> â†’
                <a href="guia-preparacao.html">ğŸ“ PreparaÃ§Ã£o</a> â†’
                <span>Fase 1</span>
            </div>
            <h1>ğŸ¯ Fase 1: MVP - FundaÃ§Ã£o</h1>
            <p>Implemente o sistema bÃ¡sico funcional com IA respondendo leads</p>
            <div class="phase-meta">
                <span class="badge">â±ï¸ 6 semanas</span>
                <span class="badge">ğŸ“Š MÃ©dio</span>
                <span class="badge">ğŸ¯ MVP Funcional</span>
            </div>
        </header>

        <nav class="nav-sticky">
            <a href="#visao">VisÃ£o Geral</a>
            <a href="#sprint1">Sprint 1</a>
            <a href="#sprint2">Sprint 2</a>
            <a href="#sprint3">Sprint 3</a>
            <a href="#testes">Testes</a>
        </nav>

        <div class="content">
            <section id="visao">
                <h2>ğŸ“‹ VisÃ£o Geral da Fase 1</h2>
                <div class="card card-info">
                    <h3>ğŸ¯ Objetivo</h3>
                    <p>Ao final desta fase, vocÃª terÃ¡ um sistema MVP completo com:</p>
                    <ul>
                        <li>âœ… IA Claude respondendo mensagens WhatsApp 24/7</li>
                        <li>âœ… Sistema de scoring automÃ¡tico de leads</li>
                        <li>âœ… NotificaÃ§Ãµes Telegram para corretores</li>
                        <li>âœ… Contexto e memÃ³ria de conversas</li>
                        <li>âœ… Pipeline completo de processamento</li>
                    </ul>
                </div>

                <div class="timeline-overview">
                    <div class="timeline-item">
                        <strong>Sprint 1 (Semanas 1-2)</strong>
                        <p>Setup bÃ¡sico: Claude, WhatsApp, Telegram</p>
                    </div>
                    <div class="timeline-item">
                        <strong>Sprint 2 (Semanas 3-4)</strong>
                        <p>IntegraÃ§Ã£o IA + Mensageria com contexto</p>
                    </div>
                    <div class="timeline-item">
                        <strong>Sprint 3 (Semanas 5-6)</strong>
                        <p>Sistema completo e orquestraÃ§Ã£o</p>
                    </div>
                </div>
            </section>

            <section id="sprint1">
                <h2>ğŸ“… Sprint 1: Setup BÃ¡sico (Semanas 1-2)</h2>

                <h3>Tarefa 1.1: ServiÃ§o Claude AI</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>ğŸ“ apps/api/src/ai/services/claude.service.ts</span>
                        <button onclick="copyCode(this)">ğŸ“‹ Copiar</button>
                    </div>
                    <pre><code>import Anthropic from '@anthropic-ai/sdk';

export class ClaudeService {
  private client: Anthropic;
  private requestCount = 0;
  private dailyCost = 0;

  constructor() {
    this.client = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY,
    });
  }

  async generateResponse(
    prompt: string,
    context?: string,
    options?: {
      maxTokens?: number;
      temperature?: number;
    }
  ): Promise<string> {
    try {
      const maxTokens = options?.maxTokens || 2000;
      const temperature = options?.temperature || 0.7;

      const message = await this.client.messages.create({
        model: 'claude-3-5-sonnet-20241022',
        max_tokens: maxTokens,
        temperature: temperature,
        messages: [
          {
            role: 'user',
            content: context ? `${context}\n\n${prompt}` : prompt
          }
        ]
      });

      // Tracking de uso
      this.requestCount++;
      const inputTokens = message.usage?.input_tokens || 0;
      const outputTokens = message.usage?.output_tokens || 0;
      this.dailyCost += this.calculateCost(inputTokens, outputTokens);

      console.log(`ğŸ“Š Claude Request #${this.requestCount}`, {
        inputTokens,
        outputTokens,
        dailyCost: `$${this.dailyCost.toFixed(4)}`
      });

      return message.content[0].type === 'text'
        ? message.content[0].text
        : '';

    } catch (error: any) {
      console.error('âŒ Erro ao chamar Claude:', error);

      // Se atingiu limite de rate, espera e tenta novamente
      if (error.status === 429) {
        console.log('â³ Rate limit atingido, aguardando 60s...');
        await this.sleep(60000);
        return this.generateResponse(prompt, context, options);
      }

      throw error;
    }
  }

  async analyze(prompt: string): Promise<any> {
    const response = await this.generateResponse(prompt);
    try {
      // Remove markdown code blocks se houver
      const cleaned = response.replace(/```json\n?|\n?```/g, '').trim();
      return JSON.parse(cleaned);
    } catch {
      return { response };
    }
  }

  private calculateCost(inputTokens: number, outputTokens: number): number {
    // PreÃ§os Claude 3.5 Sonnet (por milhÃ£o de tokens)
    const INPUT_COST_PER_M = 3.00;
    const OUTPUT_COST_PER_M = 15.00;

    const inputCost = (inputTokens / 1000000) * INPUT_COST_PER_M;
    const outputCost = (outputTokens / 1000000) * OUTPUT_COST_PER_M;

    return inputCost + outputCost;
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  getStats() {
    return {
      requestCount: this.requestCount,
      dailyCost: this.dailyCost
    };
  }

  resetDailyStats() {
    this.requestCount = 0;
    this.dailyCost = 0;
  }
}</code></pre>
                </div>

                <h3>Tarefa 1.2: ServiÃ§o WhatsApp</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>ğŸ“ apps/api/src/messaging/services/whatsapp.service.ts</span>
                        <button onclick="copyCode(this)">ğŸ“‹ Copiar</button>
                    </div>
                    <pre><code>import { Client, LocalAuth, Message } from 'whatsapp-web.js';
import qrcode from 'qrcode-terminal';

export class WhatsAppService {
  private client: Client;
  private isReady = false;

  constructor() {
    this.client = new Client({
      authStrategy: new LocalAuth({
        dataPath: './whatsapp-sessions'
      }),
      puppeteer: {
        args: ['--no-sandbox', '--disable-setuid-sandbox'],
      }
    });

    this.setupEventHandlers();
  }

  private setupEventHandlers() {
    // QR Code para autenticaÃ§Ã£o
    this.client.on('qr', (qr) => {
      console.log('ğŸ“± Escaneie o QR Code com seu WhatsApp:');
      qrcode.generate(qr, { small: true });
    });

    // Cliente autenticado
    this.client.on('authenticated', () => {
      console.log('âœ… WhatsApp autenticado!');
    });

    // Cliente pronto
    this.client.on('ready', () => {
      this.isReady = true;
      console.log('ğŸš€ WhatsApp estÃ¡ pronto!');
    });

    // Erros
    this.client.on('auth_failure', (error) => {
      console.error('âŒ Falha na autenticaÃ§Ã£o:', error);
    });

    this.client.on('disconnected', (reason) => {
      console.log('âš ï¸ WhatsApp desconectado:', reason);
      this.isReady = false;
    });
  }

  async initialize() {
    console.log('ğŸ”„ Inicializando WhatsApp...');
    await this.client.initialize();
  }

  onMessage(callback: (message: Message) => void) {
    this.client.on('message', async (message) => {
      // Ignora mensagens de grupos e mensagens prÃ³prias
      if (message.from.includes('@g.us') || message.fromMe) {
        return;
      }

      console.log(`ğŸ“© Nova mensagem de ${message.from}:`, message.body);
      callback(message);
    });
  }

  async sendMessage(to: string, text: string): Promise<void> {
    if (!this.isReady) {
      throw new Error('WhatsApp nÃ£o estÃ¡ pronto');
    }

    try {
      // Formata nÃºmero se necessÃ¡rio
      const chatId = to.includes('@c.us') ? to : `${to}@c.us`;
      await this.client.sendMessage(chatId, text);
      console.log(`âœ… Mensagem enviada para ${to}`);
    } catch (error) {
      console.error('âŒ Erro ao enviar mensagem:', error);
      throw error;
    }
  }

  async sendMessageWithTyping(to: string, text: string): Promise<void> {
    const chatId = to.includes('@c.us') ? to : `${to}@c.us`;
    const chat = await this.client.getChatById(chatId);

    // Simula digitaÃ§Ã£o
    await chat.sendStateTyping();

    // Delay proporcional ao tamanho da mensagem (mais humano)
    const typingTime = Math.min(text.length * 50, 3000);
    await new Promise(resolve => setTimeout(resolve, typingTime));

    await this.sendMessage(to, text);
  }

  isClientReady(): boolean {
    return this.isReady;
  }

  async getContact(number: string) {
    const contactId = number.includes('@c.us') ? number : `${number}@c.us`;
    return await this.client.getContactById(contactId);
  }

  async destroy() {
    await this.client.destroy();
  }
}</code></pre>
                </div>

                <h3>Tarefa 1.3: ServiÃ§o Telegram</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>ğŸ“ apps/api/src/messaging/services/telegram.service.ts</span>
                        <button onclick="copyCode(this)">ğŸ“‹ Copiar</button>
                    </div>
                    <pre><code>import TelegramBot from 'node-telegram-bot-api';

export class TelegramService {
  private bot: TelegramBot;
  private brokerChats: Map<string, string> = new Map(); // userId -> chatId

  constructor() {
    const token = process.env.TELEGRAM_BOT_TOKEN!;
    this.bot = new TelegramBot(token, { polling: true });
    this.setupCommands();
  }

  private setupCommands() {
    // Comando /start
    this.bot.onText(/\/start/, async (msg) => {
      const chatId = msg.chat.id;
      const userId = msg.from?.id.toString();

      if (userId) {
        this.brokerChats.set(userId, chatId.toString());
      }

      await this.bot.sendMessage(chatId,
        `ğŸ  *Bem-vindo ao Vivoly BI Assistant!*\n\n` +
        `VocÃª receberÃ¡ notificaÃ§Ãµes sobre:\n` +
        `âœ… Novos leads qualificados\n` +
        `âœ… Oportunidades urgentes\n` +
        `âœ… Leads com alta probabilidade de conversÃ£o\n` +
        `âœ… Agendamentos confirmados\n\n` +
        `Use /help para ver todos os comandos disponÃ­veis.`,
        { parse_mode: 'Markdown' }
      );
    });

    // Comando /help
    this.bot.onText(/\/help/, async (msg) => {
      await this.bot.sendMessage(msg.chat.id,
        `ğŸ“š *Comandos DisponÃ­veis:*\n\n` +
        `/start - Iniciar o bot\n` +
        `/help - Mostrar ajuda\n` +
        `/stats - Ver estatÃ­sticas do dia\n` +
        `/leads - Listar leads recentes\n` +
        `/hot - Ver leads quentes agora`,
        { parse_mode: 'Markdown' }
      );
    });

    // Comando /stats
    this.bot.onText(/\/stats/, async (msg) => {
      // TODO: Buscar stats reais do banco
      await this.bot.sendMessage(msg.chat.id,
        `ğŸ“Š *EstatÃ­sticas de Hoje:*\n\n` +
        `ğŸ“© Mensagens recebidas: 47\n` +
        `ğŸ‘¤ Novos leads: 12\n` +
        `ğŸ”¥ Leads quentes: 5\n` +
        `â­ Score mÃ©dio: 67/100\n` +
        `âœ… Taxa de resposta IA: 100%`,
        { parse_mode: 'Markdown' }
      );
    });
  }

  async notifyNewLead(brokerId: string, leadData: {
    name: string;
    phone: string;
    message: string;
    score: number;
    urgency: 'baixa' | 'mÃ©dia' | 'alta';
  }) {
    const chatId = this.brokerChats.get(brokerId);
    if (!chatId) {
      console.warn(`âš ï¸ Broker ${brokerId} nÃ£o tem chat Telegram configurado`);
      return;
    }

    const urgencyEmoji = {
      'baixa': 'ğŸŸ¢',
      'mÃ©dia': 'ğŸŸ¡',
      'alta': 'ğŸ”´'
    }[leadData.urgency];

    const message =
      `${urgencyEmoji} *Novo Lead!*\n\n` +
      `ğŸ‘¤ *Nome:* ${leadData.name}\n` +
      `ğŸ“± *Telefone:* ${leadData.phone}\n` +
      `â­ *Score:* ${leadData.score}/100\n` +
      `ğŸ¯ *UrgÃªncia:* ${leadData.urgency.toUpperCase()}\n\n` +
      `ğŸ’¬ *Primeira mensagem:*\n_"${leadData.message}"_\n\n` +
      `ğŸ¤– A IA jÃ¡ iniciou a conversa!`;

    await this.bot.sendMessage(chatId, message, {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [[
          { text: 'ğŸ“ Ligar Agora', callback_data: `call_${leadData.phone}` },
          { text: 'ğŸ’¬ Ver Conversa', callback_data: `chat_${leadData.phone}` }
        ]]
      }
    });
  }

  async notifyHighScore(brokerId: string, leadData: {
    name: string;
    phone: string;
    score: number;
    reason: string;
  }) {
    const chatId = this.brokerChats.get(brokerId);
    if (!chatId) return;

    const message =
      `ğŸ”¥ *LEAD QUENTE DETECTADO!*\n\n` +
      `ğŸ‘¤ ${leadData.name}\n` +
      `ğŸ“± ${leadData.phone}\n` +
      `â­ *Score: ${leadData.score}/100*\n\n` +
      `ğŸ¯ *Por quÃª?*\n${leadData.reason}\n\n` +
      `âš¡ *AÃ‡ÃƒO RECOMENDADA:* Contato imediato!`;

    await this.bot.sendMessage(chatId, message, {
      parse_mode: 'Markdown'
    });
  }

  async sendMessage(chatId: string, text: string) {
    await this.bot.sendMessage(chatId, text, {
      parse_mode: 'Markdown'
    });
  }

  registerBrokerChat(userId: string, chatId: string) {
    this.brokerChats.set(userId, chatId);
  }
}</code></pre>
                </div>

                <div class="test-box">
                    <h4>ğŸ§ª Teste dos ServiÃ§os Sprint 1</h4>
                    <div class="code-block">
                        <div class="code-header">
                            <span>ğŸ“ apps/api/src/test-sprint1.ts</span>
                            <button onclick="copyCode(this)">ğŸ“‹ Copiar</button>
                        </div>
                        <pre><code>import { ClaudeService } from './ai/services/claude.service';
import { WhatsAppService } from './messaging/services/whatsapp.service';
import { TelegramService } from './messaging/services/telegram.service';

async function testSprint1() {
  console.log('ğŸ§ª Testando Sprint 1...\n');

  // Teste Claude
  console.log('1ï¸âƒ£ Testando Claude AI...');
  const claude = new ClaudeService();
  const response = await claude.generateResponse(
    'Responda: VocÃª estÃ¡ funcionando?'
  );
  console.log('âœ… Claude respondeu:', response.substring(0, 50) + '...\n');

  // Teste WhatsApp (apenas inicializaÃ§Ã£o)
  console.log('2ï¸âƒ£ Inicializando WhatsApp...');
  const whatsapp = new WhatsAppService();
  whatsapp.onMessage((msg) => {
    console.log('ğŸ“± Mensagem recebida:', msg.body);
  });
  await whatsapp.initialize();
  console.log('âœ… WhatsApp inicializado (escaneie QR se necessÃ¡rio)\n');

  // Teste Telegram
  console.log('3ï¸âƒ£ Testando Telegram Bot...');
  const telegram = new TelegramService();
  console.log('âœ… Telegram bot iniciado (envie /start no bot)\n');

  console.log('ğŸ‰ Todos os serviÃ§os do Sprint 1 estÃ£o funcionando!');
}

testSprint1().catch(console.error);</code></pre>
                    </div>
                    <div class="command-box">
npx tsx src/test-sprint1.ts
                    </div>
                </div>
            </section>

            <section id="sprint2">
                <h2>ğŸ“… Sprint 2: Contexto e IntegraÃ§Ã£o (Semanas 3-4)</h2>

                <h3>Tarefa 2.1: Context Builder</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>ğŸ“ apps/api/src/ai/services/context-builder.service.ts</span>
                        <button onclick="copyCode(this)">ğŸ“‹ Copiar</button>
                    </div>
                    <pre><code>import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export class ContextBuilderService {
  async buildContext(leadPhone: string, tenantId: string): Promise<string> {
    // Buscar histÃ³rico de conversas
    const messages = await prisma.message.findMany({
      where: {
        fromNumber: leadPhone,
        tenantId
      },
      orderBy: { createdAt: 'desc' },
      take: 10,
      include: {
        lead: {
          include: {
            properties: true,
            deals: true
          }
        }
      }
    });

    if (messages.length === 0) {
      return this.getNewLeadContext();
    }

    const lead = messages[0].lead;
    let context = '';

    // InformaÃ§Ãµes do lead
    context += `ğŸ¯ INFORMAÃ‡Ã•ES DO LEAD:\n`;
    context += `Nome: ${lead?.name || 'NÃ£o informado'}\n`;
    context += `Telefone: ${leadPhone}\n`;
    context += `Score Atual: ${lead?.score || 0}/100\n`;
    context += `Status: ${lead?.status || 'novo'}\n\n`;

    // HistÃ³rico de conversas
    context += `ğŸ“œ HISTÃ“RICO (Ãºltimas ${messages.length} mensagens):\n`;
    messages.reverse().forEach((msg, i) => {
      const sender = msg.fromNumber === leadPhone ? 'Lead' : 'IA';
      context += `${i + 1}. ${sender}: ${msg.content}\n`;
    });
    context += '\n';

    // ImÃ³veis de interesse
    if (lead?.properties && lead.properties.length > 0) {
      context += `ğŸ  IMÃ“VEIS DE INTERESSE:\n`;
      lead.properties.forEach((prop: any) => {
        context += `- ${prop.title} (${prop.type}, ${prop.bedrooms}Q)\n`;
      });
      context += '\n';
    }

    // NegociaÃ§Ãµes ativas
    if (lead?.deals && lead.deals.length > 0) {
      context += `ğŸ’¼ NEGOCIAÃ‡Ã•ES ATIVAS:\n`;
      lead.deals.forEach((deal: any) => {
        context += `- ${deal.propertyTitle}: ${deal.status}\n`;
      });
      context += '\n';
    }

    // PreferÃªncias conhecidas
    const preferences = this.extractPreferences(messages);
    if (preferences.length > 0) {
      context += `ğŸ¯ PREFERÃŠNCIAS CONHECIDAS:\n`;
      preferences.forEach(pref => context += `- ${pref}\n`);
    }

    return context;
  }

  private getNewLeadContext(): string {
    return `ğŸ¯ NOVO LEAD (primeira interaÃ§Ã£o)\n\n` +
           `Este Ã© um novo contato. Seja receptivo, cordial e busque entender as necessidades.\n`;
  }

  private extractPreferences(messages: any[]): string[] {
    const preferences: string[] = [];
    const content = messages.map(m => m.content.toLowerCase()).join(' ');

    // Detectar preferÃªncias bÃ¡sicas
    if (content.includes('apartamento')) preferences.push('Tipo: Apartamento');
    if (content.includes('casa')) preferences.push('Tipo: Casa');
    if (content.match(/\d+ quartos?/)) {
      const match = content.match(/(\d+) quartos?/);
      if (match) preferences.push(`Quartos: ${match[1]}`);
    }
    if (content.includes('garagem')) preferences.push('Com garagem');
    if (content.includes('urgente')) preferences.push('UrgÃªncia: Alta');

    // OrÃ§amento
    const budgetMatch = content.match(/atÃ© r?\$?\s*(\d+\.?\d*)/i);
    if (budgetMatch) {
      preferences.push(`OrÃ§amento: atÃ© R$ ${budgetMatch[1]}k`);
    }

    return preferences;
  }

  async updateLeadFromConversation(
    leadId: string,
    message: string,
    analysis: any
  ) {
    const updates: any = {};

    // Atualizar score se detectado interesse
    if (analysis.urgency === 'alta') {
      updates.score = { increment: 15 };
    } else if (analysis.urgency === 'mÃ©dia') {
      updates.score = { increment: 5 };
    }

    // Atualizar tags
    if (analysis.tags && analysis.tags.length > 0) {
      updates.tags = { push: analysis.tags };
    }

    await prisma.lead.update({
      where: { id: leadId },
      data: updates
    });
  }
}</code></pre>
                </div>

                <h3>Tarefa 2.2: Prompts do Sistema</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>ğŸ“ apps/api/src/ai/prompts/sofia-prompts.ts</span>
                        <button onclick="copyCode(this)">ğŸ“‹ Copiar</button>
                    </div>
                    <pre><code>export const SOFIA_SYSTEM_PROMPT = `
VocÃª Ã© Sofia, assistente virtual da Vivoly ImobiliÃ¡ria Premium.

ğŸ¯ SUA MISSÃƒO:
- Atender leads imobiliÃ¡rios 24/7 via WhatsApp
- Qualificar interesse e urgÃªncia
- Agendar visitas quando apropriado
- Passar leads quentes para corretores humanos
- Sempre manter tom profissional e cordial

ğŸ‘¤ PERSONALIDADE:
- Comunicativa mas objetiva
- EmpÃ¡tica e prestativa
- Conhecedora do mercado imobiliÃ¡rio
- Brasileira (use portuguÃªs BR natural)
- NÃ£o use emojis em excesso (mÃ¡ximo 2 por mensagem)

ğŸ“‹ INFORMAÃ‡Ã•ES IMPORTANTES:
1. Sempre pergunte: tipo de imÃ³vel, localizaÃ§Ã£o, orÃ§amento, urgÃªncia
2. Se lead tem pressa: priorize agendamento
3. Se lead estÃ¡ indeciso: envie opÃ§Ãµes e eduque
4. Nunca invente preÃ§os ou detalhes de imÃ³veis
5. Se nÃ£o souber algo: "Vou verificar com nossa equipe e retorno em breve"

ğŸš¨ SITUAÃ‡Ã•ES ESPECIAIS:
- Lead com orÃ§amento alto (>R$1M): notificar corretor imediatamente
- UrgÃªncia explÃ­cita: oferecer agendamento para hoje/amanhÃ£
- MÃºltiplas perguntas sem interesse: educadamente encerrar

ğŸ’¬ TOM DE VOZ:
- Informal mas profissional
- Use "vocÃª" (nÃ£o use "senhor/senhora" excessivamente)
- Seja direta: respostas curtas e objetivas
- Exemplo BOM: "Ã“timo! Temos apartamentos incrÃ­veis na regiÃ£o. Qual seu orÃ§amento?"
- Exemplo RUIM: "Muito obrigada pelo seu contato! Ficamos extremamente felizes..."

ğŸ¯ OBJETIVO FINAL:
Transformar cada conversa em uma oportunidade de negÃ³cio qualificada.
`;

export const ANALYSIS_PROMPT = `
Analise a mensagem do lead e retorne um JSON com:

{
  "urgency": "baixa" | "mÃ©dia" | "alta",
  "intent": "informacao" | "agendamento" | "negociacao" | "reclamacao",
  "sentiment": "positivo" | "neutro" | "negativo",
  "budget_mentioned": boolean,
  "preferences": {
    "property_type": string | null,
    "location": string | null,
    "bedrooms": number | null,
    "budget_max": number | null
  },
  "next_action": "respond" | "schedule" | "escalate" | "close",
  "score_impact": number, // -10 a +10
  "tags": string[]
}

Seja preciso na anÃ¡lise. UrgÃªncia "alta" apenas se explicitamente mencionado.
`;

export const RESPONSE_PROMPT = (context: string, message: string) => `
${SOFIA_SYSTEM_PROMPT}

${context}

MENSAGEM DO LEAD:
"${message}"

INSTRUÃ‡Ã•ES:
1. Responda de forma natural e conversacional
2. Avance a conversa (faÃ§a pergunta relevante se apropriado)
3. MÃ¡ximo 3 frases
4. Se detectar oportunidade de agendamento, sugira
5. Mantenha consistÃªncia com histÃ³rico

Sua resposta:
`;</code></pre>
                </div>

                <h3>Tarefa 2.3: Message Processor</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>ğŸ“ apps/api/src/ai/services/message-processor.service.ts</span>
                        <button onclick="copyCode(this)">ğŸ“‹ Copiar</button>
                    </div>
                    <pre><code>import { PrismaClient } from '@prisma/client';
import { ClaudeService } from './claude.service';
import { ContextBuilderService } from './context-builder.service';
import { RESPONSE_PROMPT, ANALYSIS_PROMPT } from '../prompts/sofia-prompts';

const prisma = new PrismaClient();

export class MessageProcessorService {
  private claudeService: ClaudeService;
  private contextBuilder: ContextBuilderService;

  constructor() {
    this.claudeService = new ClaudeService();
    this.contextBuilder = new ContextBuilderService();
  }

  async processIncomingMessage(
    fromNumber: string,
    messageText: string,
    tenantId: string
  ): Promise<{
    reply: string;
    analysis: any;
    shouldNotifyBroker: boolean;
  }> {
    console.log(`\nğŸ”„ Processando mensagem de ${fromNumber}...`);

    // 1. Buscar ou criar lead
    let lead = await prisma.lead.findFirst({
      where: { phone: fromNumber, tenantId }
    });

    if (!lead) {
      lead = await prisma.lead.create({
        data: {
          phone: fromNumber,
          status: 'new',
          score: 50,
          tenantId,
          source: 'whatsapp'
        }
      });
      console.log('âœ… Novo lead criado');
    }

    // 2. Salvar mensagem recebida
    await prisma.message.create({
      data: {
        content: messageText,
        fromNumber,
        toNumber: 'system',
        direction: 'inbound',
        leadId: lead.id,
        tenantId,
        channel: 'whatsapp'
      }
    });

    // 3. Construir contexto
    const context = await this.contextBuilder.buildContext(fromNumber, tenantId);
    console.log('ğŸ“ Contexto construÃ­do');

    // 4. Analisar mensagem
    const analysis = await this.analyzeMessage(messageText);
    console.log('ğŸ§  AnÃ¡lise:', analysis);

    // 5. Gerar resposta
    const reply = await this.generateReply(context, messageText);
    console.log('ğŸ’¬ Resposta gerada');

    // 6. Salvar resposta
    await prisma.message.create({
      data: {
        content: reply,
        fromNumber: 'system',
        toNumber: fromNumber,
        direction: 'outbound',
        leadId: lead.id,
        tenantId,
        channel: 'whatsapp'
      }
    });

    // 7. Atualizar score do lead
    await this.updateLeadScore(lead.id, analysis);

    // 8. Decidir se notifica corretor
    const shouldNotifyBroker = this.shouldNotifyBroker(analysis, lead);

    return {
      reply,
      analysis,
      shouldNotifyBroker
    };
  }

  private async analyzeMessage(message: string): Promise<any> {
    try {
      const analysis = await this.claudeService.analyze(
        `${ANALYSIS_PROMPT}\n\nMensagem: "${message}"`
      );
      return analysis;
    } catch (error) {
      console.error('Erro na anÃ¡lise:', error);
      return {
        urgency: 'mÃ©dia',
        intent: 'informacao',
        sentiment: 'neutro',
        next_action: 'respond',
        score_impact: 0
      };
    }
  }

  private async generateReply(context: string, message: string): Promise<string> {
    const prompt = RESPONSE_PROMPT(context, message);
    return await this.claudeService.generateResponse(prompt, undefined, {
      maxTokens: 500,
      temperature: 0.8 // Um pouco mais criativo para conversas
    });
  }

  private async updateLeadScore(leadId: string, analysis: any) {
    const scoreChange = analysis.score_impact || 0;

    if (scoreChange !== 0) {
      await prisma.lead.update({
        where: { id: leadId },
        data: {
          score: {
            increment: scoreChange
          }
        }
      });
    }
  }

  private shouldNotifyBroker(analysis: any, lead: any): boolean {
    // Notificar se:
    // 1. Lead novo com alta urgÃªncia
    if (lead.status === 'new' && analysis.urgency === 'alta') return true;

    // 2. Score passou de 80
    if (lead.score + (analysis.score_impact || 0) >= 80) return true;

    // 3. Intent Ã© agendamento ou negociaÃ§Ã£o
    if (['agendamento', 'negociacao'].includes(analysis.intent)) return true;

    return false;
  }
}</code></pre>
                </div>
            </section>

            <section id="sprint3">
                <h2>ğŸ“… Sprint 3: OrquestraÃ§Ã£o Completa (Semanas 5-6)</h2>

                <h3>Tarefa 3.1: AI Orchestrator (IntegraÃ§Ã£o Final)</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>ğŸ“ apps/api/src/ai/ai-orchestrator.service.ts</span>
                        <button onclick="copyCode(this)">ğŸ“‹ Copiar</button>
                    </div>
                    <pre><code>import { WhatsAppService } from '../messaging/services/whatsapp.service';
import { TelegramService } from '../messaging/services/telegram.service';
import { MessageProcessorService } from './services/message-processor.service';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export class AIOrchestrator {
  private whatsapp: WhatsAppService;
  private telegram: TelegramService;
  private processor: MessageProcessorService;

  constructor() {
    this.whatsapp = new WhatsAppService();
    this.telegram = new TelegramService();
    this.processor = new MessageProcessorService();
  }

  async initialize() {
    console.log('ğŸš€ Inicializando AI Orchestrator...\n');

    // Inicializar WhatsApp
    await this.whatsapp.initialize();

    // Configurar handler de mensagens
    this.whatsapp.onMessage(async (message) => {
      await this.handleIncomingMessage(message);
    });

    console.log('âœ… AI Orchestrator pronto!\n');
    console.log('ğŸ“± Aguardando mensagens no WhatsApp...');
    console.log('ğŸ¤– Sofia estÃ¡ online!\n');
  }

  private async handleIncomingMessage(message: any) {
    const startTime = Date.now();

    try {
      console.log(`\n${'='.repeat(60)}`);
      console.log(`ğŸ“¨ NOVA MENSAGEM RECEBIDA`);
      console.log(`${'='.repeat(60)}`);
      console.log(`De: ${message.from}`);
      console.log(`ConteÃºdo: ${message.body}`);
      console.log(`HorÃ¡rio: ${new Date().toLocaleString('pt-BR')}`);

      // Processar mensagem (anÃ¡lise + geraÃ§Ã£o de resposta)
      const result = await this.processor.processIncomingMessage(
        message.from,
        message.body,
        'default-tenant' // TODO: detectar tenant real
      );

      // Enviar resposta com efeito de digitaÃ§Ã£o
      await this.whatsapp.sendMessageWithTyping(
        message.from,
        result.reply
      );

      console.log(`\nâœ… Resposta enviada: ${result.reply.substring(0, 80)}...`);

      // Notificar corretor se necessÃ¡rio
      if (result.shouldNotifyBroker) {
        await this.notifyBroker(message.from, result);
      }

      const elapsed = Date.now() - startTime;
      console.log(`\nâ±ï¸ Processado em ${elapsed}ms`);
      console.log(`${'='.repeat(60)}\n`);

    } catch (error) {
      console.error('\nâŒ ERRO ao processar mensagem:', error);

      // Resposta de fallback
      await this.whatsapp.sendMessage(
        message.from,
        'Desculpe, tive um problema tÃ©cnico. Um corretor entrarÃ¡ em contato em breve! ğŸ™'
      );
    }
  }

  private async notifyBroker(leadPhone: string, result: any) {
    try {
      // Buscar lead
      const lead = await prisma.lead.findFirst({
        where: { phone: leadPhone }
      });

      if (!lead) return;

      // Buscar corretor responsÃ¡vel (ou usar padrÃ£o)
      const broker = await prisma.user.findFirst({
        where: {
          role: 'BROKER',
          tenantId: lead.tenantId
        }
      });

      if (!broker?.telegramUserId) {
        console.warn('âš ï¸ Nenhum corretor com Telegram configurado');
        return;
      }

      // Enviar notificaÃ§Ã£o
      await this.telegram.notifyNewLead(broker.telegramUserId, {
        name: lead.name || 'Nome nÃ£o informado',
        phone: leadPhone,
        message: result.analysis.intent || 'Mensagem recebida',
        score: lead.score,
        urgency: result.analysis.urgency || 'mÃ©dia'
      });

      console.log('ğŸ“¢ Corretor notificado via Telegram');

    } catch (error) {
      console.error('âŒ Erro ao notificar corretor:', error);
    }
  }

  async shutdown() {
    console.log('\nğŸ›‘ Desligando AI Orchestrator...');
    await this.whatsapp.destroy();
    await prisma.$disconnect();
    console.log('âœ… Shutdown concluÃ­do');
  }
}

// ============================================
// INICIALIZAÃ‡ÃƒO DO SISTEMA
// ============================================

if (require.main === module) {
  const orchestrator = new AIOrchestrator();

  // Inicializar
  orchestrator.initialize().catch((error) => {
    console.error('âŒ Erro fatal na inicializaÃ§Ã£o:', error);
    process.exit(1);
  });

  // Graceful shutdown
  process.on('SIGINT', async () => {
    console.log('\n\nâš ï¸ Recebido SIGINT...');
    await orchestrator.shutdown();
    process.exit(0);
  });

  process.on('SIGTERM', async () => {
    console.log('\n\nâš ï¸ Recebido SIGTERM...');
    await orchestrator.shutdown();
    process.exit(0);
  });
}</code></pre>
                </div>

                <h3>Tarefa 3.2: Arquivo Principal de InicializaÃ§Ã£o</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>ğŸ“ apps/api/src/main.ts</span>
                        <button onclick="copyCode(this)">ğŸ“‹ Copiar</button>
                    </div>
                    <pre><code>import { AIOrchestrator } from './ai/ai-orchestrator.service';

async function bootstrap() {
  console.clear();
  console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                           â•‘
â•‘     ğŸ  VIVOLY BI + IA SYSTEM                             â•‘
â•‘     Powered by Claude AI                                  â•‘
â•‘                                                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  `);

  console.log('ğŸ“‹ Checando configuraÃ§Ãµes...\n');

  // Validar variÃ¡veis de ambiente
  const requiredEnvVars = [
    'ANTHROPIC_API_KEY',
    'TELEGRAM_BOT_TOKEN',
    'DATABASE_URL'
  ];

  const missing = requiredEnvVars.filter(v => !process.env[v]);

  if (missing.length > 0) {
    console.error('âŒ VariÃ¡veis de ambiente faltando:');
    missing.forEach(v => console.error(`   - ${v}`));
    process.exit(1);
  }

  console.log('âœ… Todas as variÃ¡veis configuradas\n');

  // Inicializar sistema
  const orchestrator = new AIOrchestrator();
  await orchestrator.initialize();

  console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  âœ… SISTEMA OPERACIONAL                                   â•‘
â•‘                                                           â•‘
â•‘  ğŸ“± WhatsApp: Conectado                                   â•‘
â•‘  ğŸ¤– Claude IA: Online                                     â•‘
â•‘  ğŸ“¢ Telegram: Ativo                                       â•‘
â•‘                                                           â•‘
â•‘  ğŸ¯ Sofia estÃ¡ pronta para atender leads!                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  `);
}

bootstrap();</code></pre>
                </div>

                <div class="command-box">
npx tsx src/main.ts
                </div>
            </section>

            <section id="testes">
                <h2>ğŸ§ª Testes Completos do MVP</h2>

                <div class="card card-warning">
                    <h3>âš ï¸ Antes de Testar</h3>
                    <p>Certifique-se de que:</p>
                    <ul>
                        <li>âœ… VariÃ¡veis de ambiente estÃ£o configuradas (.env)</li>
                        <li>âœ… Banco de dados estÃ¡ rodando (PostgreSQL)</li>
                        <li>âœ… Migrations foram executadas (npx prisma migrate dev)</li>
                        <li>âœ… VocÃª tem crÃ©ditos nas APIs (Anthropic)</li>
                        <li>âœ… WhatsApp estÃ¡ pronto para escanear QR Code</li>
                    </ul>
                </div>

                <h3>Teste 1: Conversa Completa Simulada</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span>ğŸ“ apps/api/src/tests/test-full-conversation.ts</span>
                        <button onclick="copyCode(this)">ğŸ“‹ Copiar</button>
                    </div>
                    <pre><code>import { MessageProcessorService } from '../ai/services/message-processor.service';

async function testConversation() {
  console.log('ğŸ§ª Testando conversa completa...\n');

  const processor = new MessageProcessorService();
  const leadPhone = '5511999999999';
  const tenantId = 'test-tenant';

  const conversation = [
    'Oi, estou procurando apartamento',
    '2 quartos, na zona sul de SP',
    'Meu orÃ§amento Ã© atÃ© 500 mil',
    'Preciso com urgÃªncia, para este mÃªs',
    'Pode agendar uma visita?'
  ];

  for (const message of conversation) {
    console.log(`\nğŸ‘¤ Lead: ${message}`);

    const result = await processor.processIncomingMessage(
      leadPhone,
      message,
      tenantId
    );

    console.log(`ğŸ¤– Sofia: ${result.reply}`);
    console.log(`ğŸ“Š AnÃ¡lise:`, {
      urgency: result.analysis.urgency,
      intent: result.analysis.intent,
      shouldNotify: result.shouldNotifyBroker
    });

    // Pequeno delay entre mensagens
    await new Promise(r => setTimeout(r, 2000));
  }

  console.log('\nâœ… Teste de conversa completo!');
}

testConversation().catch(console.error);</code></pre>
                </div>

                <h3>Teste 2: Sistema End-to-End</h3>
                <div class="test-box">
                    <h4>ğŸ“± Teste Manual com WhatsApp Real</h4>
                    <ol>
                        <li>Inicie o sistema: <code>npx tsx src/main.ts</code></li>
                        <li>Escaneie o QR Code com seu WhatsApp</li>
                        <li>De outro nÃºmero, envie: "OlÃ¡, quero alugar apartamento"</li>
                        <li>Continue a conversa naturalmente</li>
                        <li>Verifique notificaÃ§Ãµes no Telegram</li>
                        <li>Confira logs no terminal</li>
                    </ol>
                </div>

                <div class="card card-success">
                    <h3>âœ… CritÃ©rios de Sucesso</h3>
                    <p>O MVP estÃ¡ funcionando se:</p>
                    <ul>
                        <li>âœ… WhatsApp conecta sem erros</li>
                        <li>âœ… Mensagens sÃ£o recebidas e processadas</li>
                        <li>âœ… Claude gera respostas coerentes</li>
                        <li>âœ… Contexto Ã© mantido entre mensagens</li>
                        <li>âœ… Leads sÃ£o salvos no banco</li>
                        <li>âœ… Score Ã© atualizado corretamente</li>
                        <li>âœ… NotificaÃ§Ãµes Telegram funcionam</li>
                        <li>âœ… Sistema aguenta mÃºltiplas conversas simultÃ¢neas</li>
                    </ul>
                </div>
            </section>

            <div class="card card-info" style="margin-top: 50px;">
                <h3>ğŸ‰ ParabÃ©ns!</h3>
                <p>Se vocÃª chegou atÃ© aqui e todos os testes passaram, vocÃª tem um <strong>MVP funcional</strong> do sistema de BI + IA!</p>
                <p>PrÃ³ximo passo: <a href="guia-fase2.html">Fase 2 - InteligÃªncia AvanÃ§ada</a></p>
            </div>
        </div>

        <footer class="nav-footer">
            <a href="guia-preparacao.html" class="btn-nav">â† PreparaÃ§Ã£o</a>
            <a href="guia-index.html" class="btn-nav">ğŸ  Ãndice</a>
            <a href="guia-fase2.html" class="btn-nav">Fase 2 â†’</a>
        </footer>
    </div>

    <script src="guia-scripts.js"></script>
</body>
</html>
